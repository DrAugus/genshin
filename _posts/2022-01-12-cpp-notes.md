---
title:  cpp笔记  
layout: post  
date:   2022-01-12 09:58:58  
categories: 编程    
tags: 编程 c++  
excerpt: cpp
---

## 常用方法

### count

> 需要某元素总个数时，使用count

对于只需要知道包含特定元素的数量的应用来说，这是最简单的方式。如果count返回0，则表示不存在该元素。

```C++
if (count(v.begin(), v.end(), key))
```

### find

> 仅判断是否存在某元素，使用find

find会在查找到指定值后立即返回，所以它一般比count更快（因为count总是要遍历整个容器）。

```C++
if (std::find(v.begin(), v.end(), key) != v.end())
```

### find_if any_of

> 支持复杂条件的查找时，使用any_of(仅知道是否存在)/find_if(返回了第一个元素的迭代器)

#### std::find_if

它也能完成任务，但有点大材小用了。

find_if需要一个判别式。如果查找的值需要满足特定的条件时，比如查找小于3且大于1的值时，适合该方式。

如果有多个值符合条件，则返回查找到符合条件的第一个值的迭代器。

```C++
if (std::find_if(v.begin(), v.end(), [] (int i) { return i < 3 && i > 1 } ) != v.end())
```

#### std::any_of

与find_if类似，但它返回bool值。

如果判断式返回true，则它也返回true。否则返回false。

```C++
if (std::any_of(v.begin(), v.end(), [] (int i) { return i < 3 && i > 1 } ))
```

扩展：std::none_of，是any_of的反面。也就是，当判断式是false时它返回true，否则返回flase。

### binary_search

> 对于已经排序的vector，使用 binary_search

作为磨刀不误砍柴工的一种方式，可以对vector先排序，再查找，就可以使用二分查找了。

二分查找的时间效率为O(logn)。

```C++
sort(v.begin(), v.end());
if (std::binary_search(v.begin(), v.end(), key))
```

## 读书笔记

1.不要在头文件使用`using`，防止多个引用造成命名冲突

2.`vector`能够高效增长，不要在初始化的时候指定`vector`大小，除非所有值都一样

3.

![](/assets/res/post/cpp/class.png)

## 智能指针

> 将原生指针封装成对象，来解决堆上内存泄漏的问题。

为什么要使用智能指针：
> 智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

当栈对象生存周期结束，智能指针会调用析构函数释放之前申请的内存，从而避免内存泄漏。

智能指针是类，一定要有operator*和operator->();*传回所指的对象，->调用对象的成员。

1. shared_ptr：拥有共享对象所有权语义的智能指针；
2. weak_ptr：到 shared_ptr 所管理对象的弱引用；
3. unique_ptr：拥有独有对象所有权语义的智能指针。

C++11常用的智能指针有shared_ptr，它采用计数的方法，记录当前内存被几个智能指针引用。计数内存在堆上分配。 当新增一个引用时，计数+1；失去一个引用，计数-1.当引用为0，智能指针自动释放申请的内存资源。

初始化shared_ptr可以通过make_shared函数，或者，通过构造函数传入普通指针，并通过get获得指针。

智能指针有内存泄露的情况

> 当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

例如：parent有一个shared_ptr类型的成员指向孩子，而child也有一个shared_ptr类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c和p，随后将c和p分别又赋值给child的智能指针成员parent和parent的智能指针成员child。从而形成了一个循环引用。

为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

shared_ptr多个指针指向相同的对象，也叫共享指针。shared_ptr采用了引用计数的方式，更好地解决了赋值与拷贝的问题，每一个shared_ptr的拷贝都指向相同的内存，每拷贝一次内部的引用计数加1，每析构一次内部的引用计数减1，为0时自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取时需要加锁。

成员函数：

(1) get： 获得内部对象的指针；

(2) swap：交换所管理的对象；

(3) reset：替换所管理的对象；

(4) use_count：返回shared_ptr所指对象的引用计数；

(5) operator*和operator->：解引用存储的对象指针；

(6) operator=：对shared_ptr赋值；

(7) operator bool：检查是否有关联的管理对象；

(8) owner_before：提供基于拥有者的共享指针排序。

交换： std::swap(std::shared_ptr) 特化的swap算法用于交换两个智能指针。

初始化：通过构造函数传入指针初始化，也可以使用std::make_shared 或 std::allocate_shared 函数初始化。

注意事项：

(1) 不能将指针直接赋值给一个智能指针，一个是类，一个是指针。不能使用类似这样的形式 shared_ptr<int> p = new int；

(2) 避免循环引用，这是shared_ptr的一个最大陷阱，导致内存泄漏，这一点在weak_ptr中将得到完善；

(3) 管理数组指针时，需要制定Deleter以使用delete[]操作符销毁内存，shared_ptr并没有针对数组的特化版本；

(4) 不能把一个原生指针交给两个智能指针对象管理，对其它智能指针也是如此。

当对象中存在指针成员时，除了在复制对象时需要考虑自定义拷贝构造函数，还应该考虑

1. 当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现；
2. 当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。
3. 浅拷贝带来内存泄漏的问题，本质在于析构函数释放多次堆内存，使用std::shared_ptr，可以完美解决这个问题。
