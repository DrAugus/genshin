---
layout: post
title:  "C++20"
date:   2021-08-12 11:24:23
categories: 转 C++
tags: 转 C++
---

<span class="image main">
<a href="https://zhuanlan.zhihu.com/p/137646370" target="_blank" ><img height="50" src="https://img.shields.io/badge/-10分钟速览 C++20 新增特性 原址-F08080 " alt="10分钟速览 C++20 新增特性"/></a>
</span>

<div class="RichText ztext Post-RichText css-hnrfcf" options="[object Object]"><p>原文链接: </p><div class="RichText-LinkCardContainer"><a target="_blank" href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/" data-draft-node="block" data-draft-type="link-card" data-text="C++20 新增特性" class="LinkCard new css-1wr1m8" data-image="https://pic1.zhimg.com/v2-7c3c8f2b0be17cc955e51d8ceb25a85c_180x120.jpg" data-image-width="2178" data-image-height="776" data-za-detail-view-id="172"><span class="LinkCard-contents"><span class="LinkCard-title two-line">C++20 新增特性</span><span class="LinkCard-desc"><span style="display: inline-flex; align-items: center;">&ZeroWidthSpace;<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>jimmysue.me/c-20-features/</span></span><span class="LinkCard-image" style="height: 60px;"><img src="https://pic1.zhimg.com/v2-7c3c8f2b0be17cc955e51d8ceb25a85c_180x120.jpg" alt=""></span></a></div><ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E6%2596%25B0%25E5%25A2%259E%25E5%2585%25B3%25E9%2594%25AE%25E5%25AD%2597keywords" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">新增关键字(keywords)</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E6%2596%25B0%25E5%25A2%259E%25E6%25A0%2587%25E8%25AF%2586%25E7%25AC%25A6identifies" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">新增标识符(Identifies)</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E6%25A8%25A1%25E5%259D%2597modules" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">模块(Modules)</a></li><ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25BC%2598%25E7%2582%25B9" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">优点</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E5%2588%259B%25E5%25BB%25BA%25E6%25A8%25A1%25E5%259D%2597" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">创建模块</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E5%25BC%2595%25E7%2594%25A8%25E6%25A8%25A1%25E5%259D%2597" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">引用模块</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23import-%25E5%25A4%25B4%25E6%2596%2587%25E4%25BB%25B6" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">import 头文件</a></li></ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23ranges" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Ranges</a></li><ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25BE%258B%25E5%25AD%2590" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">例子</a></li></ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E5%258D%258F%25E7%25A8%258Bcoroutines" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">协程(Coroutines)</a></li><ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AF%25E5%258D%258F%25E7%25A8%258B" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">什么是协程</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25BE%258B%25E5%25AD%2590vc" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">例子(VC++)</a></li></ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23concepts" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Concepts</a></li><ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E5%25A6%2582%25E4%25BD%2595%25E5%25AE%259A%25E4%25B9%2589" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">如何定义</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25BD%25BF%25E7%2594%25A8" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">使用</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25BE%258B%25E5%25AD%2590-1" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">例子</a></li></ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23lambda-%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%25E7%259A%2584%25E6%259B%25B4%25E6%2596%25B0" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Lambda 表达式的更新</a></li><ul><li><a href="https://link.zhihu.com/?target=http%3A//%253Ccode%253Ejimm%253C/code%253Eysue.me/c-20-features/%23-this-%25E9%259C%2580%25E8%25A6%2581%25E6%2598%25BE%25E5%25BC%258F%25E6%258D%2595%25E8%258E%25B7this%25E5%258F%2598%25E9%2587%258F" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">[=, this] 需要显式捕获this变量</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E6%25A8%25A1%25E6%259D%25BF%25E5%25BD%25A2%25E5%25BC%258F%25E7%259A%2584-lambda-%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">模板形式的 Lambda 表达式</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23lambda-%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%25E6%2589%2593%25E5%258C%2585%25E6%258D%2595%25E8%258E%25B7pack-expansion" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Lambda 表达式打包捕获(Pack Expansion)</a></li></ul><li>常量表达式(constexpr) 的更新</li><ul><li><code><a href="https://zhuanlan.zhihu.com/p/137646370/%3C/code%3Ehttp://jimmysue.me/c-20-features/#constexpr-string--vector" class="internal" data-za-detail-view-id="1043">constexpr string &amp; vector</a></code></li></ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E5%258E%259F%25E5%25AD%2590atomic%25E6%2599%25BA%25E8%2583%25BD%25E6%258C%2587%25E9%2592%2588" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">原子(Atomic)智能指针</a></li><ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25BE%258B%25E5%25AD%2590-2" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">例子</a></li></ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E8%2587%25AA%25E5%258A%25A8%25E5%2590%2588%25E6%25B5%2581joining-%25E5%258F%25AF%25E4%25B8%25AD%25E6%2596%25ADcancellable-%25E7%259A%2584%25E7%25BA%25BF%25E7%25A8%258B" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">自动合流(Joining), 可中断(Cancellable) 的线程</a></li><ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25BE%258B%25E5%25AD%2590-3" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">例子</a></li></ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23c20-%25E5%2590%258C%25E6%25AD%25A5synchronization%25E5%25BA%2593" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">C++20 同步(Synchronization)库</a></li><ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23stdatomic_ref" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">std::atomic_ref</a></li></ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E5%2585%25B6%25E4%25BB%2596%25E6%259B%25B4%25E6%2596%25B0" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">其他更新</a></li><ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E6%258C%2587%25E5%25AE%259A%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596designated-initializers" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">指定初始化(Designated Initializers)</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E8%2588%25AA%25E5%25A4%25A9%25E9%25A3%259E%25E6%259C%25BA%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6-" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">航天飞机操作符 &lt;=&gt;</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E8%258C%2583%25E5%259B%25B4-for-%25E5%25BE%25AA%25E7%258E%25AF%25E8%25AF%25AD%25E5%258F%25A5%25E6%2594%25AF%25E6%258C%2581%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">范围 for 循环语句支持初始化</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E9%259D%259E%25E7%25B1%25BB%25E5%259E%258B%25E6%25A8%25A1%25E6%259D%25BF%25E5%25BD%25A2%25E5%258F%2582%25E6%2594%25AF%25E6%258C%2581%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">非类型模板形参支持字符串</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23likely-unlikely" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">[[likely]], [[unlikely]]</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E6%2597%25A5%25E5%258E%2586calendar%25E5%2592%258C%25E6%2597%25B6%25E5%258C%25BAtimezone%25E5%258A%259F%25E8%2583%25BD" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">日历(Calendar)和时区(Timezone)功能</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23stdspan" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">std::span</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E7%2589%25B9%25E6%2580%25A7%25E6%25B5%258B%25E8%25AF%2595%25E5%25AE%258F" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">特性测试宏</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23version" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">&lt;version&gt;</a></li><li><code><a href="https://zhuanlan.zhihu.com/p/137646370/%3C/code%3Ehttp://jimmysue.me/c-20-features/#consteval-%E5%87%BD%E6%95%B0" class="internal" data-za-detail-view-id="1043">consteval 函数</a></code></li><li><code><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23constinit" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">constinit</a></code></li><li> 用 using 引用 enum 类型</li><li>格式化库(std::format)</li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E5%25A2%259E%25E5%258A%25A0%25E6%2595%25B0%25E5%25AD%25A6%25E5%25B8%25B8%25E9%2587%258F" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">增加数学常量</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23stdsource_location" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">std::source_location</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23nodiscardreason" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">[[nodiscard(reason)]]</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25BD%258D%25E8%25BF%2590%25E7%25AE%2597" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">位运算</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E4%25B8%2580%25E4%25BA%259B%25E5%25B0%258F%25E6%259B%25B4%25E6%2596%25B0" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">一些小更新</a></li></ul><li><a href="https://link.zhihu.com/?target=http%3A//jimmysue.me/c-20-features/%23%25E5%258F%2582%25E8%2580%2583%25E8%25B5%2584%25E6%2596%2599" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">参考资料</a> </li></ul><hr><h2>新增关键字(keywords)</h2><ul><li>concept</li><li>requires</li><li>constinit</li><li>consteval</li><li>co_await</li><li>co_return</li><li>co_yield</li><li>char8_t</li></ul><h2>新增标识符(Identifies)</h2><ul><li>import</li><li>module</li></ul><h2>模块(Modules)</h2><h3>优点</h3><ul><li>没有头文件</li><li>声明实现仍然可分离, 但非必要</li><li>可以<b>显式</b>指定那些导出(类, 函数等)</li><li>不需要头文件重复引入宏 (include guards)</li><li>模块之间名称可以相同不会冲突</li><li>模块只处理一次, 编译更快 (<i>头文件每次引入都需要处理</i>)</li><li>预处理宏只在模块内有效</li><li>模块引入顺序无关紧要</li></ul><h3>创建模块</h3><div class="highlight"><pre><code class="language-cpp"><span class="c1">// cppcon.cpp 
</span><span class="c1"></span><span class="k">export</span> <span class="n">module</span> <span class="n">cppcon</span><span class="p">;</span> 
<span class="k">namespace</span> <span class="n">CppCon</span> <span class="p">{</span> 
    <span class="k">auto</span> <span class="nf">GetWelcomeHelper</span><span class="p">()</span> <span class="p">{</span>  <span class="k">return</span> <span class="s">"Welcome to CppCon 2019!"</span><span class="p">;</span>  <span class="p">}</span> 
    <span class="k">export</span> <span class="k">auto</span> <span class="nf">GetWelcome</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetWelcomeHelper</span><span class="p">();}</span> 
<span class="p">}</span>
</code></pre></div><h3>引用模块</h3><div class="highlight"><pre><code class="language-cpp"><span class="c1">// main.cpp 
</span><span class="c1"></span><span class="n">import</span> <span class="n">cppcon</span><span class="p">;</span> 
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span> 
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">CppCon</span><span class="o">::</span><span class="n">GetWelcome</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div><h3>import 头文件</h3><ul><li>import &lt;iostream&gt;</li><li>隐式地将 <code>iostream</code> 转换为模块</li><li>加速构建, 因为 iostream 只会处理一次</li><li>和预编译头 (PCH) 具有相似的效果</li></ul><h2>Ranges</h2><p><b>Ranges</b> 是什么 ?</p><ul><li><code>Range</code> 代表一串元素, 或者一串元素中的一段</li><li>类似 begin/end 对</li></ul><p><b>好处</b>:</p><ul><li>简化语法和方便使用</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">};</span> 
<span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">data</span><span class="p">));</span> 
<span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="c1">// 使用 Ranges
</span></code></pre></div><ul><li>防止 begin/end 不配对</li><li>使变换/过滤等串联操作成为可能</li></ul><p><b>相关功能</b></p><ul><li><b>视图</b>(View): 延迟计算, 不持有, 不改写</li><li><b>Actions</b>: 即时处理(eagerly evaluated), 改写</li><li><b>Algorithms</b>: 所有接受 begin/end 对的算法都可用</li><li>Views 和 actions 使用管道符<code>|</code>串联</li></ul><h3>例子</h3><ul><li>串联视图</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span> 
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">data</span> <span class="o">|</span> 
              <span class="n">views</span><span class="o">::</span><span class="n">remove_if</span><span class="p">([](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;})</span> <span class="o">|</span> 
              <span class="n">views</span><span class="o">::</span><span class="n">transform</span><span class="p">([](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">);});</span> 
<span class="c1">// result = {"2", "4", "6", "8", "10" };
</span><span class="c1">// 注意 以上操作被延迟, 当你遍历result的时候才触发
</span></code></pre></div><ul><li>串联actions</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span> 
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">data</span> <span class="o">|</span> <span class="n">actions</span><span class="o">::</span><span class="n">sort</span> <span class="o">|</span> <span class="n">actions</span><span class="o">::</span><span class="n">unique</span><span class="p">;</span>
</code></pre></div><ul><ul><li>排序然后去重</li><li>操作会原地对<code>data</code>进行更改, 然后返回</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li>过滤和变换</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">accumulate</span> <span class="p">(</span>
                        <span class="n">view</span><span class="o">::</span><span class="n">ints</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> 
                        <span class="n">view</span><span class="o">::</span><span class="n">transform</span><span class="p">([](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;})</span> <span class="o">|</span> 
                        <span class="n">view</span><span class="o">::</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> 
                        <span class="mi">0</span><span class="p">);</span>
</code></pre></div><ul><ul><li><code>view::ints(1)</code> 产生一个无限的整型数列</li><li>平方</li><li>取前10个元素, 然后累加(accumulate)<br><b>所有的计算延迟到<code>accumulate</code>累加遍历的时候发生</b></li></ul></ul><h2>协程(Coroutines)</h2><h3>什么是协程</h3><ul><li>它是一个函数</li><li>具备如下关键字之一:</li><ul><li><code>co_wait</code>: 挂起协程, 等待其它计算完成</li><li><code>co_return</code>: 从协程返回 (协程 <code>return</code> 禁止使用)</li><li><code>co_yield</code>: 同 python yield, 弹出一个值, 挂起协程, 下一次调用继续协程的运行</li><li><code>for co_await</code> 循环体</li></ul></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">for</span> <span class="k">co_await</span> <span class="p">(</span><span class="k">for</span><span class="o">-</span><span class="n">range</span><span class="o">-</span><span class="nl">declaration</span><span class="p">:</span> <span class="n">expression</span><span class="p">)</span> <span class="n">statement</span>
</code></pre></div><p><b>用处</b></p><ul><li>简化如下问题的实现:</li><ul><li>generator</li><li>异步I/O</li><li>延迟计算</li><li>事件驱动的程序</li></ul></ul><h3>例子(VC++)</h3><div class="highlight"><pre><code class="language-cpp"><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">GetSequenceGenerator</span><span class="p">(</span> 
    <span class="kt">int</span> <span class="n">startValue</span><span class="p">,</span> 
    <span class="n">size_t</span> <span class="n">numberOfValues</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">+</span> <span class="n">numberOfValues</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span> 
        <span class="n">time_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">());</span> 
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span> <span class="k">co_yield</span> <span class="n">i</span><span class="p">;</span> 
    <span class="p">}</span> 
<span class="p">}</span> 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">gen</span> <span class="o">=</span> <span class="n">GetSequenceGenerator</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> 
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">value</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">"(Press enter for next value)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
        <span class="n">cin</span><span class="p">.</span><span class="n">ignore</span><span class="p">();</span> 
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div><h2>Concepts</h2><ul><li>对模板类和函数的模板形参的约束</li><li>编译期断言</li><li>可声明多个</li></ul><h3>如何定义</h3><div class="highlight"><pre><code class="language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">concept</span> <span class="n">Incrementable</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="n">x</span><span class="o">++</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">;};</span>
</code></pre></div><h3>使用</h3><div class="highlight"><pre><code class="language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="n">Incrementable</span> <span class="n">T</span><span class="o">&gt;</span> 
<span class="kt">void</span> <span class="n">Foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">);</span> 

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">requires</span> <span class="n">Incrementable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="k">requires</span> <span class="n">Incrementable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">Incrementable</span> <span class="k">auto</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div><h3>例子</h3><ul><li>具备<code>size()</code> 方法, 且返回<code>size_t</code></li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">concept</span> <span class="n">HasSize</span> <span class="o">=</span> <span class="k">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">){</span>
<span class="p">{</span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><ul><li>组合concept</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">requires</span> <span class="n">Incrementable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">Decrementable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">);</span>
<span class="c1">// or
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">Incr_Decrementable</span> <span class="o">=</span> <span class="n">Incrementable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">Decrementable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">Incr_Decrementable</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div><h2>Lambda 表达式的更新</h2><h3>[=, this] 需要显式捕获<code>this</code>变量</h3><ul><li>C++20 之前 <code>[=]</code> 隐式捕获<code>this</code></li><li>C++20 开始 需要显式捕获this: <code>[=, this]</code></li></ul><h3>模板形式的 Lambda 表达式</h3><p>可以在<code>lambda</code>表达式中使用模板语法</p><div class="highlight"><pre><code class="language-cpp"><span class="p">[]</span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">};</span>
<span class="p">[]</span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">};</span>
<span class="p">[]</span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">};</span>
</code></pre></div><p><b>原因1</b></p><ul><li>C++20之前: 获取 vector 元素类型, 你需要这么写</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">vec</span><span class="p">){</span>
<span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="k">typename</span> <span class="k">decltype</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul><li>C++20 你可以:</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[]</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">){</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><b>原因2</b>: 方便获取通用lambda形参类型, 访问静态函数</p><ul><li>c++20 以前</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">){</span>
<span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">T</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">T</span><span class="o">::</span><span class="n">static_function</span><span class="p">();</span>
<span class="k">using</span> <span class="n">Iterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">iterator</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul><li>C++20 开始</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[]</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">){</span>
<span class="n">T</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">T</span><span class="o">::</span><span class="n">static_function</span><span class="p">();</span>
<span class="k">using</span> <span class="n">Iterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">iterator</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><b>原因3</b>: 完美转发</p><ul><li>pre C++20:</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div><ul><li>since C++20</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[]</span><span class="o">&lt;</span><span class="k">typename</span> <span class="err">…</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="err">…</span><span class="n">args</span><span class="p">){</span>
<span class="k">return</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div><h3>Lambda 表达式捕获支持打包展开(Pack Expansion)</h3><ul><li>Pre C++20</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">delay_invoke</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
<span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="p">...]{</span>
<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="p">...);</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul><li>Since C++20</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">delay_invoke</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
<span class="c1">// Pack Expansion:  args = std::move(args)...  
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">args</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">args</span><span class="p">)...](){</span>
<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="p">...);</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2>常量表达式(<code>constexpr</code>) 的更新</h2><ul><li><code>constexpr</code> 虚函数</li><ul><li><code>constexpr</code> 的虚函数可以重写非 <code>constexpr</code> 的虚函数</li><li>非 <code>constexpr</code> 虚函数可以重写 <code>constexpr</code> 的虚函数</li></ul><li><code>constexpr</code> 函数可以:</li><ul><li>使用 <code>dynamic_cast()</code> 和 <code>typeid</code></li><li>动态内存分配</li><li>更改<code>union</code>成员的值</li><li>包含 <code>try/catch</code></li><ul><li>但是<b>不允许</b> <b><code>throw</code></b> <b>语句</b></li><li>在触发常量求值的时候 try/catch 不发生作用</li><li>需要开启 <code>constexpr std::vector</code> </li></ul></ul></ul><h3><code>constexpr</code> string &amp; vector</h3><ul><li><code>std::string</code> 和 <code>std::vector</code> 类型现在可以作为 <code>constexpr</code></li><li>未来需要支持 <code>constexpr</code> 反射</li></ul><h2>原子(Atomic)智能指针</h2><ul><li>智能指针(shared_ptr)线程安全吗?</li><ul><li><b>是</b>: 引用计数控制单元线程安全, 保证对象只被释放一次</li><li><b>否</b>: 对于数据的读写没有线程安全</li></ul><li>如何将智能指针变成线程安全?</li><ul><li>使用 <code>mutex</code> 控制智能指针的访问</li><li>使用全局非成员原子操作函数访问, 诸如: std::atomic_load(), atomic_store(), …</li><ul><li><b>缺点</b>: 容易出错, 忘记使用这些操作</li></ul><li>C++20: <code>atomic&lt;shared_ptr&lt;T&gt;&gt;</code>, <code>atomic&lt;weak_ptr&lt;T&gt;&gt;</code></li><ul><li>内部原理可能使用了<code>mutex</code></li><li>全局非成员原子操作函数标记为不推荐使用(deprecated)</li></ul></ul></ul><h3>例子</h3><div class="highlight"><pre><code class="language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">concurrent_stack</span> <span class="p">{</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
<span class="n">T</span> <span class="n">t</span><span class="p">;</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">atomic_shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head</span><span class="p">;</span>
<span class="c1">// C++11: 去掉 "atomic_" 并且在访问时, 需要用
</span><span class="c1"></span>    <span class="c1">// 特殊的函数控制线程安全, 例如用std::tomic_load
</span><span class="c1"></span><span class="k">public</span><span class="o">:</span>
<span class="k">class</span> <span class="nc">reference</span> <span class="p">{</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
<span class="o">&lt;</span><span class="n">snip</span><span class="o">&gt;</span>
<span class="p">};</span>
<span class="k">auto</span> <span class="nf">find</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">();</span> <span class="c1">// C++11: atomic_load(&amp;head)
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">t</span> <span class="o">!=</span> <span class="n">t</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="k">return</span> <span class="n">reference</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">auto</span> <span class="nf">front</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">reference</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">push_front</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">p</span><span class="p">)){</span>
<span class="p">}</span> <span class="c1">// C++11: atomic_compare_exchange_weak(&amp;head, &amp;p-&gt;next, p); }     
</span><span class="c1"></span>    <span class="kt">void</span> <span class="n">pop_front</span><span class="p">()</span> <span class="p">{</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">head</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
<span class="p">}</span> <span class="c1">// C++11: atomic_compare_exchange_weak(&amp;head, &amp;p, p-&gt;next);
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p><i>例子来自 Herb Sutter 的 N4162 论文</i></p><h2>自动合流(Joining), 可中断(Cancellable) 的线程</h2><ul><li>std::jthread</li><ul><li>头文件 &lt;thread&gt;</li><li>支持中断</li><li>析构函数中自动 Join</li><ul><li>析构函数调用 <code>stop_source.request_stop()</code> 然后 <code>join()</code> </li></ul></ul><li>中断线程执行</li><ul><li>头文件 &lt;stop_token&gt;</li><li><code>std::stop_token</code></li><ul><li>用来查询线程是否中断</li><li>可以和<code>condition_variable_any</code>配合使用</li></ul><li><code>std::stop_source</code></li><ul><li>用来请求线程停止运行</li><li>stop_resources 和 stop_tokens 都可以查询到停止请求</li></ul><li><code>std::stop_callback</code></li><ul><li>如果对应的<code>stop_token</code> 被要求终止, 将会触发回调函数</li><li>用法: std::stop_callback myCallback(myStopToken, []{ /* … */ });</li></ul></ul></ul><h3>例子</h3><ul><li>自动合流 Join</li></ul><blockquote><i>std::thread 在析构函数中如果线程</i> <i><code>joinable()</code></i> <i>会直接调用</i> <i><code>std::terminate()</code></i> <i>直接导致程序退出</i></blockquote><div class="highlight"><pre><code class="language-cpp"><span class="kt">void</span> <span class="nf">DoWorkPreCpp20</span><span class="p">()</span> <span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">job</span><span class="p">([]</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">});</span>
<span class="k">try</span> <span class="p">{</span>
<span class="c1">// ... Do something else ...
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
<span class="n">job</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="k">throw</span><span class="p">;</span> <span class="c1">// rethrow
</span><span class="c1"></span>    <span class="p">}</span>
<span class="n">job</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">DoWork</span><span class="p">()</span> <span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">jthread</span> <span class="n">job</span><span class="p">([]</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">});</span>
<span class="c1">// ... Do something else ...
</span><span class="c1"></span><span class="p">}</span> <span class="c1">// jthread destructor automatically calls join()
</span></code></pre></div><ul><li>中断</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">jthread</span> <span class="n">job</span><span class="p">([](</span><span class="n">std</span><span class="o">::</span><span class="n">stop_token</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">token</span><span class="p">.</span><span class="n">stop_requested</span><span class="p">())</span> <span class="p">{</span>
<span class="c1">//...
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">});</span>
<span class="c1">//... job.request_stop();
</span><span class="c1">// auto source = job.get_stop_source()
</span><span class="c1">// auto token = job.get_stop_token()
</span></code></pre></div><h2>C++20 同步(Synchronization)库</h2><ul><li>信号量(Semaphore), 维基百科请走<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E4%25BF%25A1%25E5%258F%25B7%25E9%2587%258F" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">这里</a></li><ul><li>头文件<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/header/semaphore" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">&lt;semaphore&gt;</a></li><li>轻量级的同步原语</li><li>可用来实现任何其他同步概念, 如: mutex, latches, barriers, …</li><li>两种类型:</li><ul><li>多元信号量(counting semaphore): 建模非负值资源计数</li><li>二元信号量(binary semaphore): 只有一个插孔, 两种状态, 最适合实现<code>mutex</code> </li></ul></ul><li><code>std::atomic</code> 等待和通知接口</li><ul><li>等待/阻塞在原子对象直到其值发生改变, 通过通知函数发送通知</li><li>比轮训(polling)来的更高效</li><li>方法</li><ul><li><code>wait()</code></li><li><code>notify_one()</code></li><li><code>notify_all()</code> </li></ul></ul><li>锁存器(Latch)和屏障(Barrier)</li><ul><li>辅助线程条件同步</li></ul><li>锁存器(Latches)</li><ul><li>头文件&lt;latch&gt;</li><li>线程的同步点</li><ul><li>线程将阻塞在这个位置, 直到到达的线程个数达标才放行, 放行之后不再关闭</li></ul><li>锁存器只会作用一次</li></ul><li>屏障(Barriers)</li><ul><li>&lt;barrier&gt;</li><li>多个阶段</li><li>每个阶段中</li><ul><li>一个参与者运行至屏障点时被阻塞，需要等待其他参与者都到达屏障点, 当到达线程数达标之后</li><li>阶段完成的回调将被执行</li><li>线程计数器被重置</li><li>开启下一阶段</li><li>线程得以继续执行</li></ul></ul></ul><h3>std::atomic_ref</h3><ul><li>头文件&lt;atomic&gt;</li><li>Atomic 引用</li><li>通过引用访问变为原子操作, 被引用对象可以为非原子类型</li></ul><h2>其他更新</h2><h3>指定初始化(Designated Initializers) </h3><div class="highlight"><pre><code class="language-cpp"><span class="k">struct</span> <span class="nc">Data</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">anInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aString</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Data</span> <span class="n">d</span><span class="p">{</span> <span class="p">.</span><span class="n">aString</span> <span class="o">=</span> <span class="s">"Hello"</span> <span class="p">};</span>
</code></pre></div><h3>航天飞机操作符 &lt;=&gt;</h3><ul><li>正规名称: <b>三路比较运算符</b></li><li>三路比较结果如下</li><ul><li>(a &lt;=&gt; b) &lt; 0 // 如果 a &lt; b 则为 true</li><li>(a &lt;=&gt; b) &gt; 0 // 如果 a &gt; b 则为 true</li><li>(a &lt;=&gt; b) == 0 // 如果 a 与 b 相等或者等价 则为 true</li></ul><li>类似于C的strcmp 函数返回-1, 0, 1</li><li><b>一般情况</b>: 自动生成所有的比较操作符, 如果对象是结构体则逐个比较, 可以用下面代码代替所有的比较运算符</li><ul><li><code>auto X::operator&lt;=&gt;(const Y&amp;) = default;</code> </li></ul><li><b>高级情况</b>: 指定返回类型(支持6种所有的比较运算符)<br></li></ul><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-07eff9491c92901416b45175c3afd5e2_b.jpg" data-caption="" data-size="normal" data-rawwidth="2178" data-rawheight="776" class="origin_image zh-lightbox-thumb" width="2178" data-original="https://pic3.zhimg.com/v2-07eff9491c92901416b45175c3afd5e2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/80/v2-07eff9491c92901416b45175c3afd5e2_720w.jpg" data-caption="" data-size="normal" data-rawwidth="2178" data-rawheight="776" class="origin_image zh-lightbox-thumb lazy" width="2178" data-original="https://pic3.zhimg.com/v2-07eff9491c92901416b45175c3afd5e2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-07eff9491c92901416b45175c3afd5e2_b.jpg" data-lazy-status="ok"></figure><p><b>示例</b>:</p><div class="highlight"><pre><code class="language-cpp"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span>
<span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="o">==</span><span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="o">==</span><span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span>
<span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>  
<span class="p">}</span>
<span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="o">&lt;</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">b</span><span class="o">&lt;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ... 其他非比较函数 ...
</span><span class="c1"></span><span class="p">};</span>
<span class="cp">#include</span> <span class="cpf">&lt;compare&gt; </span><span class="cp">
</span><span class="cp"></span><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span><span class="p">)</span>  <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 比较操作符自动生成
</span><span class="c1"></span>    <span class="c1">// ... 其他非比较函数 ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><ul><li>标准库类型支持 &lt;=&gt;</li><ul><li>vector, string, map, set, sub_match, …</li></ul><li>例如:</li></ul><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-e7f603dfcf196be88e8838ffff69ce2f_b.jpg" data-caption="" data-size="normal" data-rawwidth="1032" data-rawheight="434" class="origin_image zh-lightbox-thumb" width="1032" data-original="https://pic4.zhimg.com/v2-e7f603dfcf196be88e8838ffff69ce2f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/80/v2-e7f603dfcf196be88e8838ffff69ce2f_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1032" data-rawheight="434" class="origin_image zh-lightbox-thumb lazy" width="1032" data-original="https://pic4.zhimg.com/v2-e7f603dfcf196be88e8838ffff69ce2f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-e7f603dfcf196be88e8838ffff69ce2f_b.jpg" data-lazy-status="ok"></figure><h3>范围 for 循环语句支持初始化语句</h3><ul><li>switch 语句初始化 (C++17):</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Foo</span> <span class="nf">GetData</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">Foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="k">switch</span> <span class="p">(</span><span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">GetData</span><span class="p">();</span> <span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
<span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul><li>if 语句初始化 (C++17):</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Foo</span><span class="o">*</span> <span class="nf">GetData</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">GetData</span><span class="p">();</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// Use 'data’
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul><li>现在范围 for 循环同样支持初始化 (C++20):</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Foo</span> <span class="nf">GetData</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">Foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">GetData</span><span class="p">();</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="nl">value</span> <span class="p">:</span> <span class="n">data</span><span class="p">.</span><span class="n">values</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// Use 'data’
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3>非类型模板形参支持字符串</h3><div class="highlight"><pre><code class="language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">DoSomething</span><span class="p">()</span> <span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="n">DoSomething</span><span class="o">&lt;</span><span class="s">"CppCon"</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h3>[[likely]], [[unlikely]]</h3><p>先验概率指导编译器优化</p><div class="highlight"><pre><code class="language-cpp"><span class="k">switch</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>
<span class="na">[[likely]]</span> <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>
<span class="na">[[unlikely]]</span> <span class="k">case</span> <span class="mi">3</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3>日历(Calendar)和时区(Timezone)功能</h3><ul><li>&lt;choron&gt; 增加日历和时区的支持</li><li>只支持公历(Gregorian calendar)</li><ul><li>其他日历也可通过扩展加入, 并能和 &lt;chrono&gt; 进行交互</li></ul><li>初始化 年, 月 日的方法</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="c1">// creating a year
</span><span class="c1"></span><span class="k">auto</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">year</span><span class="p">{</span> <span class="mi">2019</span> <span class="p">};</span>
<span class="k">auto</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">2019</span><span class="n">y</span><span class="p">;</span>
<span class="c1">// creating a mouth
</span><span class="c1"></span><span class="k">auto</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">month</span><span class="p">{</span> <span class="mi">9</span> <span class="p">};</span>
<span class="k">auto</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">September</span><span class="p">;</span>
<span class="c1">// creating a day
</span><span class="c1"></span><span class="k">auto</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">day</span><span class="p">{</span> <span class="mi">18</span> <span class="p">};</span>
<span class="k">auto</span> <span class="n">d2</span> <span class="o">=</span> <span class="mi">18</span><span class="n">d</span><span class="p">;</span>
</code></pre></div><ul><li>创建完整的日期</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="n">year_mouth_day</span> <span class="n">fulldate1</span><span class="p">{</span><span class="mi">2019</span><span class="n">y</span><span class="p">,</span> <span class="n">September</span><span class="p">,</span> <span class="mi">18</span><span class="n">d</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">fulldate2</span> <span class="o">=</span> <span class="mi">2019</span><span class="n">y</span> <span class="o">/</span> <span class="n">September</span> <span class="o">/</span> <span class="mi">18</span><span class="n">d</span><span class="p">;</span>
<span class="n">year_mouth_day</span> <span class="n">fulldate3</span><span class="p">{</span><span class="n">Monday</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="n">September</span><span class="o">/</span><span class="mi">2019</span><span class="p">};</span> <span class="c1">// Monday[3] 表示第三个星期一
</span></code></pre></div><ul><li>新的事件间隔单位, 类似于秒, 分钟, …</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">using</span> <span class="n">days</span> <span class="o">=</span> <span class="n">duration</span><span class="o">&lt;</span><span class="kt">signed</span> <span class="n">interger</span> <span class="n">type</span> <span class="n">of</span> <span class="n">at</span> <span class="n">least</span> <span class="mi">25</span><span class="n">bits</span><span class="p">,</span>
<span class="n">ratio_multiply</span><span class="o">&lt;</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">24</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">hours</span><span class="o">::</span><span class="n">period</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">weeks</span> <span class="o">=</span> <span class="p">...;</span> <span class="k">using</span> <span class="n">mouths</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">using</span> <span class="n">years</span> <span class="o">=</span> <span class="p">...;</span>
</code></pre></div><ul><li>例子</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="n">weeks</span> <span class="n">w</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// 1 周
</span><span class="c1"></span><span class="n">days</span> <span class="n">d</span><span class="p">{</span><span class="n">w</span><span class="p">};</span> <span class="c1">// 将 1 周 转换成天数
</span></code></pre></div><ul><li>新的时钟类型, (之前有 <code>system_clock</code>, <code>steady_clock</code>, <code>high_resolution_clock</code>):</li><ul><li><code>utc_clock</code>: represents Coordinated Universal Time (UTC), measures time since 00:00:00 UTC, Thursday, 1 January 1970, including leap seconds</li><li><code>tai_clock</code>: represents International Atomic Time (TAI), measures time since 00:00:00, 1 January 1958, and was offseted 10 seconds ahead of UTC at that date, it does not include leap seconds</li><li><code>gps_clock</code>: represents Global Positioning System (GPS) time, measures time since 00:00:00, 6 January 1980 UTC, it does not include leap seconds</li><li><code>file_clock</code>: alias for the clock used for <code>std::filesystem::file_time_type</code>, epoch is unspecified</li></ul><li>新增<code>system_clock</code>相关的别名</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Duration</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">sys_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="p">,</span> <span class="n">Duration</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">sys_seconds</span> <span class="o">=</span> <span class="n">sys_time</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">sys_days</span> <span class="o">=</span> <span class="n">sys_time</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">days</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// 用例:
</span><span class="c1"></span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">t</span> <span class="o">=</span>  <span class="n">sys_days</span><span class="p">{</span> <span class="mi">2019</span><span class="n">y</span> <span class="o">/</span> <span class="n">September</span> <span class="o">/</span> <span class="mi">18</span><span class="n">d</span> <span class="p">};</span> <span class="c1">// date -&gt; time_point
</span><span class="c1"></span><span class="k">auto</span> <span class="n">yearmonthday</span> <span class="o">=</span>  <span class="n">year_month_day</span><span class="p">{</span> <span class="n">floor</span><span class="o">&lt;</span><span class="n">days</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">};</span> <span class="c1">// time_point -&gt; date
</span></code></pre></div><ul><li>日期 + 事件</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">sys_days</span><span class="p">{</span><span class="mi">2019</span><span class="n">y</span><span class="o">/</span><span class="n">September</span><span class="o">/</span><span class="mi">18</span><span class="n">d</span><span class="p">}</span> <span class="o">+</span> <span class="mi">9</span><span class="n">h</span> <span class="o">+</span> <span class="mi">35</span><span class="n">min</span> <span class="o">+</span> <span class="mi">10</span><span class="n">s</span><span class="p">;</span> <span class="c1">// 2019-09-18 09:35:10 UTC
</span></code></pre></div><ul><li>时区转换</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="c1">// Convert UTC to Denver
</span><span class="c1"></span><span class="nl">time</span><span class="p">:</span> <span class="n">zoned_time</span> <span class="n">denver</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"America/Denver"</span><span class="p">,</span> <span class="n">t</span> <span class="p">};</span>
<span class="c1">// Construct a local time in Denver:
</span><span class="c1"></span><span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">zoned_time</span><span class="p">{</span>
<span class="s">"America/Denver"</span><span class="p">,</span>  <span class="n">local_days</span><span class="p">{</span><span class="n">Wednesday</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">September</span> <span class="o">/</span> <span class="mi">2019</span><span class="p">}</span> <span class="o">+</span> <span class="mi">9</span><span class="n">h</span>
<span class="p">};</span>
<span class="c1">// Get current local time:
</span><span class="c1"></span><span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">zoned_time</span><span class="p">{</span> <span class="n">current_zone</span><span class="p">(),</span> <span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="p">};</span>
</code></pre></div><h3>std::span</h3><ul><li>头文件&lt;span&gt;</li><li>某段连续数据的”视图”</li><li>不持有数据, 不分配和销毁数据</li><li>拷贝非常快, 推荐复制的方式传参(类似 <code>string_view</code>)</li><li>不支持数据跨步(stride)</li><li>可通过运行期确定长度也可编译器确定长度</li></ul><div class="highlight"><pre><code class="language-cpp"><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span> <span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">42</span><span class="o">&gt;</span> <span class="n">a</span> <span class="p">{</span><span class="n">data</span><span class="p">};</span> <span class="c1">// fixed-size: 42 ints
</span><span class="c1"></span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span><span class="n">data</span><span class="p">};</span> <span class="c1">// dynamic-size: 42 ints
</span><span class="c1"></span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">50</span><span class="o">&gt;</span> <span class="n">c</span> <span class="p">{</span><span class="n">data</span><span class="p">};</span> <span class="c1">// compilation error
</span><span class="c1"></span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">{</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">len</span> <span class="p">};</span> <span class="c1">// dynamic-size: len ints
</span></code></pre></div><h3>特性测试宏</h3><p>通过它可以判断编译器是否支持某个功能, 例如</p><ul><li>语言特性</li><ul><li><code>__has_cpp_attribute(fallthrough)</code></li><li><code>__cpp_binary_literals</code></li><li><code>__cpp_char8_t</code></li><li><code>__cpp_coroutines</code> </li></ul><li>标准库特性</li><ul><li><code>__cpp_lib_concepts</code></li><li><code>__cpp_lib_ranges</code></li><li><code>__cpp_lib_scoped_lock</code> </li></ul></ul><h3>&lt;version&gt;</h3><p>包含 C++ 标准库版本, 发布日期, 版权证书, 特性宏等</p><h3><code>consteval</code> 函数</h3><p><code>constexpr</code> 函数可能编译期执行, 也可以在运行期执行, <code>consteval</code> 只能在编译器执行, 如果不满足要求编译不通过</p><h3><code>constinit</code></h3><p>强制指定以常量方式初始化</p><div class="highlight"><pre><code class="language-cpp"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">GetStringDyn</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="s">"dynamic init"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">constexpr</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">GetString</span><span class="p">(</span><span class="kt">bool</span> <span class="n">constInit</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">constInit</span> <span class="o">?</span>
<span class="s">"constant init"</span> <span class="o">:</span>
<span class="n">GetStringDyn</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">constinit</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span> <span class="c1">// ✔
</span><span class="c1"></span><span class="n">constinit</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// ❌
</span></code></pre></div><h3>用 <code>using</code> 引用 <code>enum</code> 类型</h3><div class="highlight"><pre><code class="language-cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">CardTypeSuit</span> <span class="p">{</span>
<span class="n">Clubs</span><span class="p">,</span>
<span class="n">Diamonds</span><span class="p">,</span>
<span class="n">Hearts</span><span class="p">,</span>
<span class="n">Spades</span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">GetString</span><span class="p">(</span><span class="k">const</span> <span class="n">CardTypeSuit</span> <span class="n">cardTypeSuit</span><span class="p">)</span> <span class="p">{</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">cardTypeSuit</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">CardTypeSuit</span><span class="o">::</span><span class="nl">Clubs</span><span class="p">:</span>
<span class="k">return</span> <span class="s">"Clubs"</span><span class="p">;</span>
<span class="k">case</span> <span class="n">CardTypeSuit</span><span class="o">::</span><span class="nl">Diamonds</span><span class="p">:</span>
<span class="k">return</span> <span class="s">"Diamonds"</span><span class="p">;</span>
<span class="k">case</span> <span class="n">CardTypeSuit</span><span class="o">::</span><span class="nl">Hearts</span><span class="p">:</span>
<span class="k">return</span> <span class="s">"Hearts"</span><span class="p">;</span>
<span class="k">case</span> <span class="n">CardTypeSuit</span><span class="o">::</span><span class="nl">Spades</span><span class="p">:</span>
<span class="k">return</span> <span class="s">"Spades"</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">GetString</span><span class="p">(</span><span class="k">const</span> <span class="n">CardTypeSuit</span> <span class="n">cardTypeSuit</span><span class="p">)</span> <span class="p">{</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">cardTypeSuit</span><span class="p">)</span> <span class="p">{</span>
<span class="k">using</span> <span class="k">enum</span> <span class="nc">CardTypeSuit</span><span class="p">;</span> <span class="c1">// 这里
</span><span class="c1"></span>        <span class="k">case</span> <span class="nl">Clubs</span><span class="p">:</span> <span class="k">return</span> <span class="s">"Clubs"</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">Diamonds</span><span class="p">:</span> <span class="k">return</span> <span class="s">"Diamonds"</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">Hearts</span><span class="p">:</span> <span class="k">return</span> <span class="s">"Hearts"</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">Spades</span><span class="p">:</span> <span class="k">return</span> <span class="s">"Spades"</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3>格式化库(<code>std::format</code>)</h3><p>不展开, 类似<code>Python</code> 的格式化,</p><div class="highlight"><pre><code class="language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"Hello CppCon {}!"</span><span class="p">,</span> <span class="mi">2019</span><span class="p">);</span>
</code></pre></div><h3>增加数学常量</h3><p>再也不用为 M_PI 发愁啦</p><ul><li>头文件 &lt;numbers&gt;</li><li>包含 e, log2e, log10e pi, inv_pi, inv_sqrt pi ln2, ln10 sqrt2, sqrt3, inv_sqrt3 egamma</li></ul><h3>std::source_location</h3><p>用于获取代码位置, 对于日志和错误信息尤其有用</p><h3>[[nodiscard(reason)]]</h3><p>表明返回值不可抛弃, 加入理由的支持</p><div class="highlight"><pre><code class="language-cpp"><span class="na">[[nodiscard("Ignoring the return value will result in memory leaks.")]]</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">GetData</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre></div><h3>位运算</h3><p>加入循环移位, 计数0和1位等功能</p><h3>一些小更新</h3><ul><li>字符串支持 starts_with, ends_with</li><li>map 支持 contains 查询是否存在某个键</li><li>list 和 forward list 的 remove, remove_if 和 unique 操作返回 size_type 表明删除个数</li><li>&lt;algorithm&gt; 增加 shift_left, shift_right</li><li><code>midpoint</code> 计算中位数, 可避免溢出</li><li><code>lerp</code> 线性插值 <code>lerp( float a, float b, float t )</code> 返回  <img src="https://www.zhihu.com/equation?tex=a+%2B+t%28b-a%29" alt="[公式]" eeimg="1" data-formula="a + t(b-a)"> </li><li>新的向量化策略 <code>unsequenced_policy(execution::unseq)</code></li></ul><div class="highlight"><pre><code class="language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Hello world!"</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">starts_with</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">);</span> <span class="c1">// starts_with, ends_with
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">map</span> <span class="n">myMap</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="s">"one"</span><span class="n">s</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="s">"two"</span><span class="n">s</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="s">"three"</span><span class="n">s</span><span class="p">}</span> <span class="p">};</span>
<span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">myMap</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// contains, 再也不用  .find() == .end() 了
</span></code></pre></div><h2>参考资料</h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DY652wQqbYEI" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">https://www.</span><span class="visible">youtube.com/watch?</span><span class="invisible">v=Y652wQqbYEI</span><span class="ellipsis"></span></a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.modernescpp.com/index.php/a-new-thread-with-c-20-std-jthread" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">https://www.</span><span class="visible">modernescpp.com/index.p</span><span class="invisible">hp/a-new-thread-with-c-20-std-jthread</span><span class="ellipsis"></span></a></li></ul></div>